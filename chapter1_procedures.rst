1.1 Элементы программирования
========================

Всякий язык программирования обладает тремя механизмами:
#. элементарные выражения, представляющий элементарные сущности, с которым язык имеет дело
#. средства комбинирования, с помощью которых из простых объектов составляются сложные
#. средства абстракции, с помощью которых сложные объекты можно называть и обращаться с ними как с единым целым.

1.1.1 Выражения
^^^^^^^^^^^^^^^

Выражения, образуемые путем заключения списка выражения в скобки с целью обозначить применение функции к аргументам, называются **комбинациями**(combinations).
Самый левый элемент в списке называют **оператором** (operator), а остальные элементы - **операндами** (operands). Значение комбинации вычисляется путем применения процедуры, задаваемой оператором, к аргументами, которые являются значениями операндов.

Примеры::

	(+ 137 439)
        (* 5 99)
        (/ 10 2)

Соглашение, по которому оператор ставится слева от операндов, известно как **префиксная нотация**. Несмотря на то, что префиксная нотация отличается от общепринятой математической записи, у нее есть свои преимущества. Одно из них состоит в том, что префиксная запись может распространяться на процедуры с произвольным количеством аргументов.
Например::

	(+ 21 35 12 7)
        (* 25 4 12)

Второе преимущество префиксной нотации в том, что она естественным образом расширяется, позволяя комбинациям вкладываться друг в друга, т.е. допускает комбинации, элементы которых сами являются комбинациями.
::

	(+ (- 10 7) (* 2 8))
	(- (* 5 (* 18 4 2)) (/ 8 (+ 4 10)))

Из-за того, что последний пример тяжело читать, используется следующее правило форматирования
::

	(- (* 5
              (* 18 4 2)) 
           (/ 8
              (+ 4 10)))

Согласно этому правилу, комбинации записываются так, чтобы ее операнды выравнивались вертикально.

1.1.2. Имена и окружение
^^^^^^^^^^^^^^^^^^^^^^^^^

В диалекте Лиспа Scheme мы даем объектам имена с помощью слова **define**. Предложение:
::

	(define size 2)

заставляет интерпретатор связать значение 2 с именем size. После того, как имя size связано со значением 2, мы можем указывать на значение 2 с помощью имени:
::

	size
        2

Слово define служит в нашем языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций.

Ясно, что раз интерпретатор способен ассоциировать значения с символами и затем вспоминать их, то он должен иметь некоторого рода память, сохраняющую пары имя-объект. Эта память называется окружением (enivironment), а точнее глобальным окружением (global environment).

1.1.3. Составные процедуры
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Общая форма определения процедуры такова:
::

	(define (имя <формальные параметры>)) (тело))

Имя - тот символ, с которым нужно связать в окружении определение процедуры. Параметры - имена, которые в теле процедуры используются для отсылки к соответствующим аргументам процедуры. Тело - это выражение, которое вычислит результат применения процедуры, когда параметры будут заменены аргументами, в которым процедура будет применяться.
Например:
::

	(define (square x) (* x x))
        (square 21)
        441

Кроме того, мы можем использовать square при определении других процедур. Например x^2 + y^2 можно записать следующим образом:
::

	(+ (square x) (square y))
	(define (f a)
               (sum-of-squares (+ a 1) (* a 2)))

1.1.4. Подстановочная модель применения процедуры
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Чтобы применить составную процедуру к аргументам, требуется вычислить тело процедуры, заменив каждый формальный параметр соответствующим аргументом.
Чтобы проиллюстрировать данный процесс, вычислим комбинацию:
::

	(f 5)

где f - процедура, определенная в пред. разделе. Начнем с того, что восстанавливаем тело f:
::

	(sum-of-squares (+ a 1) (* a 2))

Затем, заменяем формальный параметр a на аргумент 5:
::

	(sum-of-squares (+ 5 1) (* 5 2))

Таким образом, задача сводится к вычислению комбинации с двумя операндами и оператором sum-of-squares. Вычисление этой комбинации включает три подзадачи. Нам нужно вычислить оператор, чтобы получить процедуру, которую требуется применить, а также операнды, чтобы получить аргументы. При этом (+ 5 1) дает 6, а (* 5 2) дает 10, так что нам требуется применить процедуру sum-of-squares к 6 и 10. Эти значения подставляются на место формальных параметров x и y в теле sum-of-squares, приводя выражение к
::

	(+ (square 6) (square 10))

Когда мы используем определение square, это приводится к:
::

	(+ (* 6 6) (* 10 10))

Что при умножении сводится к
::

	(+ 36 100)

И наконец к:
::
	
	136

Только, что описанный нами процесс называется подстановочной моделью (substitution model). Ее можно использовать как модель, которая определяет смысл понятия применения процедуры. Имеются, однако, две детали, которые необходимо подчеркнуть:
#. Цель подстановочной модели - помочь нам представить, как применяются процедуры, а не дать описание того, как на самом деле работает интерпретатор.
#. На протяжении этой книги мы представим последовательность усложняющихся моделей того, как работает интерпретатор, завершающуюся полным воплощением интепретатора и компилятора.

Аппликативный и нормальный порядки вычисления
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

В соответствии с описанием из пред. раздела интерпретатор сначала вычисляет оператор и операнды, а затем применяет получившуюся процедуру к получившимся аргументам. Но это не единственный способ осуществлять вычисления. Другая модель вычисления не вычисляет аргументы, пока не понадобятся их значение. Вместо этого, она подставляет на место параметров выражения-операнды, пока не получит выражение, в котором присутствуют только элементарные операторы, и лишь затем вычисляет его. Если бы мы использовали этот метод, вычисление
::

	(f 5)

прошло бы последовательность подстановок
::

	(sum-of-squares (+ 5 1) (* 5 2))
	(+ (square (+ 5 1)) (square (* 5 2)) )
        (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)) ))

За которыми последуют редукции:
::

	(+ (* 6 6) (* 10 10))
	(+ 36 100)
        136

Это дает тот же результат, что и предыдущая модель вычислений, но процесс его получения отличается.
Альтернативный метод "полная подстановка, затем редукция" известен под названием нормальный порядок вычислений (normal-order evaluation), в противовес методу "вычисление аргументов, затем применение процедуры", которое называется аппликативным порядком вычислений (applicative-order evaluation).

В Лиспе используется аппликативный порядок вычисления, отчасти из-за дополнительной эффективности, которую дает возможность не вычислять многократно выражения, а отчасти, что важнее, потому что с нормальным порядком вычислений становится очень сложно обращаться, как только мы покидаем область процедур, которые можно смоделировать с помощью подстановки. С другой стороны, нормальный порядок вычисления, может быть весьма ценным инструментом, и некоторые его применения мы рассмотрим позже.

Условные выражения и предикаты
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
В Лиспе существует особая форма для обозначения разбора случаев. Она называется cond и используется так:
::

	(define (abs x)
           (cond ((> x 0) x)
                 ((= x 0) 0)
                 ((< x 0) (-x))))

Общая форма условного выражения такова:
::

	(cond (<p1> <e1>)
              (<p2> <e2>)
              ...
              (<pN> <eN>))

Она состоит из символа cond, за которым следуют заключенные в скобки пары выражений (<p> <e>), называемых ветвями (clauses). В каждой из этих пар, первое выражение предикат, то есть выражение, значение которого интепретируется как истина или ложь.
Условные выражения вычисляются так: сначала вычисляется предикат. Если его значением является ложь, то вычисляется предикат <p2>. Если значение <p2> также ложь, вычисляется <p3>. Этот процесс будет продолжаться до тех пор, пока не будет найден предикат, значением которого является истина, и в этом случае интерпретатор возвращает значение соответствующего выражения-следствия в качестве значения всего условного выражения. Если ни один из <p> ни окажется истинным, значение условного выражения не определено.
Процедуру вычисления модуля числа, можно написать и так:
::

	(define (abs x)
            (cond ((< x 0) (-x))
                  (else x)))

Else - специальный символ, который в заключительной ветви cond можно использовать на месте <p>. Это заставляет cond вернуть в качестве значения значение соответствующего <e> в случае, если все предыдущие ветви были пропущены.
Вот еще один способ написать процедуру вычисления модуля:
::

	(define (abs x)
            (if (< x 0)
                (-x)
                x))

Здесь употребляется особая форма if, ограниченный вид условного выражения. Общая форма if такова:
::

	(if <предикат> <следствие> <альтернатива>)

В дополнении к элементарным предикатам вроде <, =, > существуют операции логической композиции, которые позволяют нам конструировать составные предикаты.
::

	(and <e1> ... <eN>)

Интерпретатор вычисляет значение выражения <e> по одному, слева направо. Если какое-нибудь из <e> дает ложное значение, значение всего выражения and - ложь, и остальные не вычисляются. Если все <e> дают истинные значения, значением выражения and является значение последнего из них.
::

	(or <e1> ... <eN>)
	(not <e>)

Примеры:
::

	(and (> x 5) (< x 10))

Определение предиката, которые проверяет, что одно число больше или равно другому, как:
::

	(define (>= x y)
            (or (> x y) (= x y)))

Или как:
::

	(define (>= x y)
             (not (< x y)))
