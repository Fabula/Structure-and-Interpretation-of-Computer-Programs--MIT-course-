1.1 Элементы программирования
========================

Всякий язык программирования обладает тремя механизмами:

	* элементарные выражения, представляющий элементарные сущности, с которым язык имеет дело
	* средства комбинирования, с помощью которых из простых объектов составляются сложные
	* средства абстракции, с помощью которых сложные объекты можно называть и обращаться с ними как с единым целым.

1.1.1 Выражения
^^^^^^^^^^^^^^^

Выражения, образуемые путем заключения списка выражения в скобки с целью обозначить применение функции к аргументам, называются **комбинациями** (combinations).
Самый левый элемент в списке называют **оператором** (operator), а остальные элементы - **операндами** (operands). Значение комбинации вычисляется путем применения процедуры, задаваемой оператором, к аргументами, которые являются значениями операндов.

Примеры::

	(+ 137 439)
        (* 5 99)
        (/ 10 2)

Соглашение, по которому оператор ставится слева от операндов, известно как **префиксная нотация**. Несмотря на то, что префиксная нотация отличается от общепринятой математической записи, у нее есть свои преимущества. Одно из них состоит в том, что префиксная запись может распространяться на процедуры с произвольным количеством аргументов.
Например::

	(+ 21 35 12 7)
        (* 25 4 12)

Второе преимущество префиксной нотации в том, что она естественным образом расширяется, позволяя комбинациям вкладываться друг в друга, т.е. допускает комбинации, элементы которых сами являются комбинациями.
::

	(+ (- 10 7) (* 2 8))
	(- (* 5 (* 18 4 2)) (/ 8 (+ 4 10)))

Из-за того, что последний пример тяжело читать, используется следующее правило форматирования
::

	(- (* 5
              (* 18 4 2)) 
           (/ 8
              (+ 4 10)))

Согласно этому правилу, комбинации записываются так, чтобы ее операнды выравнивались вертикально.

1.1.2. Имена и окружение
^^^^^^^^^^^^^^^^^^^^^^^^^

В диалекте Лиспа Scheme мы даем объектам имена с помощью слова **define**. Предложение:
::

	(define size 2)

заставляет интерпретатор связать значение 2 с именем size. После того, как имя size связано со значением 2, мы можем указывать на значение 2 с помощью имени:
::

	size
        2

Слово define служит в нашем языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций.

Ясно, что раз интерпретатор способен ассоциировать значения с символами и затем вспоминать их, то он должен иметь некоторого рода память, сохраняющую пары имя-объект. Эта память называется окружением (enivironment), а точнее глобальным окружением (global environment).

1.1.3. Составные процедуры
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Общая форма определения процедуры такова:
::

	(define (имя <формальные параметры>)) (тело))

Имя - тот символ, с которым нужно связать в окружении определение процедуры. Параметры - имена, которые в теле процедуры используются для отсылки к соответствующим аргументам процедуры. Тело - это выражение, которое вычислит результат применения процедуры, когда параметры будут заменены аргументами, в которым процедура будет применяться.
Например:
::

	(define (square x) (* x x))
        (square 21)
        441

Кроме того, мы можем использовать square при определении других процедур. Например x^2 + y^2 можно записать следующим образом:
::

	(+ (square x) (square y))
	(define (f a)
               (sum-of-squares (+ a 1) (* a 2)))

1.1.4. Подстановочная модель применения процедуры
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Чтобы применить составную процедуру к аргументам, требуется вычислить тело процедуры, заменив каждый формальный параметр соответствующим аргументом.
Чтобы проиллюстрировать данный процесс, вычислим комбинацию:
::

	(f 5)

где f - процедура, определенная в пред. разделе. Начнем с того, что восстанавливаем тело f:
::

	(sum-of-squares (+ a 1) (* a 2))

Затем, заменяем формальный параметр a на аргумент 5:
::

	(sum-of-squares (+ 5 1) (* 5 2))

Таким образом, задача сводится к вычислению комбинации с двумя операндами и оператором sum-of-squares. Вычисление этой комбинации включает три подзадачи. Нам нужно вычислить оператор, чтобы получить процедуру, которую требуется применить, а также операнды, чтобы получить аргументы. При этом (+ 5 1) дает 6, а (* 5 2) дает 10, так что нам требуется применить процедуру sum-of-squares к 6 и 10. Эти значения подставляются на место формальных параметров x и y в теле sum-of-squares, приводя выражение к
::

	(+ (square 6) (square 10))

Когда мы используем определение square, это приводится к:
::

	(+ (* 6 6) (* 10 10))

Что при умножении сводится к
::

	(+ 36 100)

И наконец к:
::
	
	136

Только, что описанный нами процесс называется подстановочной моделью (substitution model). Ее можно использовать как модель, которая определяет смысл понятия применения процедуры. Имеются, однако, две детали, которые необходимо подчеркнуть:
#. Цель подстановочной модели - помочь нам представить, как применяются процедуры, а не дать описание того, как на самом деле работает интерпретатор.
#. На протяжении этой книги мы представим последовательность усложняющихся моделей того, как работает интерпретатор, завершающуюся полным воплощением интепретатора и компилятора.

Аппликативный и нормальный порядки вычисления
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

В соответствии с описанием из пред. раздела интерпретатор сначала вычисляет оператор и операнды, а затем применяет получившуюся процедуру к получившимся аргументам. Но это не единственный способ осуществлять вычисления. Другая модель вычисления не вычисляет аргументы, пока не понадобятся их значение. Вместо этого, она подставляет на место параметров выражения-операнды, пока не получит выражение, в котором присутствуют только элементарные операторы, и лишь затем вычисляет его. Если бы мы использовали этот метод, вычисление
::

	(f 5)

прошло бы последовательность подстановок
::

	(sum-of-squares (+ 5 1) (* 5 2))
	(+ (square (+ 5 1)) (square (* 5 2)) )
        (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)) ))

За которыми последуют редукции:
::

	(+ (* 6 6) (* 10 10))
	(+ 36 100)
        136

Это дает тот же результат, что и предыдущая модель вычислений, но процесс его получения отличается.
Альтернативный метод "полная подстановка, затем редукция" известен под названием нормальный порядок вычислений (normal-order evaluation), в противовес методу "вычисление аргументов, затем применение процедуры", которое называется аппликативным порядком вычислений (applicative-order evaluation).

В Лиспе используется аппликативный порядок вычисления, отчасти из-за дополнительной эффективности, которую дает возможность не вычислять многократно выражения, а отчасти, что важнее, потому что с нормальным порядком вычислений становится очень сложно обращаться, как только мы покидаем область процедур, которые можно смоделировать с помощью подстановки. С другой стороны, нормальный порядок вычисления, может быть весьма ценным инструментом, и некоторые его применения мы рассмотрим позже.

Условные выражения и предикаты
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
В Лиспе существует особая форма для обозначения разбора случаев. Она называется cond и используется так:
::

	(define (abs x)
           (cond ((> x 0) x)
                 ((= x 0) 0)
                 ((< x 0) (-x))))

Общая форма условного выражения такова:
::

	(cond (<p1> <e1>)
              (<p2> <e2>)
              ...
              (<pN> <eN>))

Она состоит из символа cond, за которым следуют заключенные в скобки пары выражений (<p> <e>), называемых ветвями (clauses). В каждой из этих пар, первое выражение предикат, то есть выражение, значение которого интепретируется как истина или ложь.
Условные выражения вычисляются так: сначала вычисляется предикат. Если его значением является ложь, то вычисляется предикат <p2>. Если значение <p2> также ложь, вычисляется <p3>. Этот процесс будет продолжаться до тех пор, пока не будет найден предикат, значением которого является истина, и в этом случае интерпретатор возвращает значение соответствующего выражения-следствия в качестве значения всего условного выражения. Если ни один из <p> ни окажется истинным, значение условного выражения не определено.
Процедуру вычисления модуля числа, можно написать и так:
::

	(define (abs x)
            (cond ((< x 0) (-x))
                  (else x)))

Else - специальный символ, который в заключительной ветви cond можно использовать на месте <p>. Это заставляет cond вернуть в качестве значения значение соответствующего <e> в случае, если все предыдущие ветви были пропущены.
Вот еще один способ написать процедуру вычисления модуля:
::

	(define (abs x)
            (if (< x 0)
                (-x)
                x))

Здесь употребляется особая форма if, ограниченный вид условного выражения. Общая форма if такова:
::

	(if <предикат> <следствие> <альтернатива>)

В дополнении к элементарным предикатам вроде <, =, > существуют операции логической композиции, которые позволяют нам конструировать составные предикаты.
::

	(and <e1> ... <eN>)

Интерпретатор вычисляет значение выражения <e> по одному, слева направо. Если какое-нибудь из <e> дает ложное значение, значение всего выражения and - ложь, и остальные не вычисляются. Если все <e> дают истинные значения, значением выражения and является значение последнего из них.
::

	(or <e1> ... <eN>)
	(not <e>)

Примеры:
::

	(and (> x 5) (< x 10))

Определение предиката, которые проверяет, что одно число больше или равно другому, как:
::

	(define (>= x y)
            (or (> x y) (= x y)))

Или как:
::

	(define (>= x y)
             (not (< x y)))

Упражнения
^^^^^^^^^^^^^^^^^^^^^^
1.1 Ниже приведена последовательность выражений. Какой результат напечает интерпретатор в ответ на каждое из них? Предполагается, что выражения вводятся в том же порядке, в каком они написаны.
::
	
	10
	(+ 5 3 4)
	(- 9 1)
	(/ 6 2)
	(+ (* 2 4) (- 4 6))
	(define a 3)
	(define b (+ a 1))
	(+ a b (* a b))
	(= a b)
	(if (and (> b a) (< b (* a b)))
	     b
 	     a)
	(cond ((= a 4) 6)
              ((= b 4) (+ 6 7 a))
              (else 25))
	(+ 2 (if (> b a) b a))
	(* (cond ((> a b) a)
	         ((< a b) b)
	         (else -1))
	   (+ a 1))

Ответ:
::

	10
	12
	8
	3
	6
	a 3
	b 4
	19
	false
	4
	16
	6
	16

1.2 Переведите следующее выражение в префиксную форму (выражение лень приводить, длинная дробь)
Ответ:
::
    (/ (+ 5
	  4
	  (- 2
	     (- 3	
	        (+ 6 4/5))))
       (* 3
	  (- 6 2)
	  (- 2 7)))

1.3 Определите процедуру, которая принимает в качестве аргументов три числа и возвращает сумму квадратов двух больших из них
Ответ:
::

	(define (three_num_sqrt a b c)
                    (cond ((and (< a c) (< a b)) (+ (square b) (square c)))  
			  ((and (< b a) (< b c)) (+ (square a) (square c)))
			  (else (+ (square a) (square b)))))

1.4 Заметим, что наша модель вычислений разрешает существование комбинаций, операторы которых составные выражения. С помощью этого наблюдения опишите, как работает следующая процедура:
::

	(define (a-plus-abs-b a b)
		  ((if (> b 0) + -) a b))

Ответ:
Процедура складывается аргумент а с модулем аргумента b. Если аргумент b процедуры положителен, то к аргументам a и b применяется оператор сложения, иначе оператор вычитания.

1.5 Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком вычислений он работает, аппликативным или нормальным. Бен определяет такие две процедуры:
::

	(define (p) (p))

	(define (test x y)
	    (if (= x 0)
		0
		y))

Затем он вычисляет выражение
::

	(test 0 (p))

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений? Какое поведение он увидит, если интерпретатор использует нормальный порядок? Объясните ответ.
Ответ:
Предположим, что интерпретатор использует аппликативный порядок вычислений, т.е. сначала вычисляет операнды и оператор, а затем применяет получившуюся процедуру к получившимся аргументам. Тогда, вычисляя аргументы процедуры test получаем:
::

	test 0 p

Применяя тело процедуры к аргументам получаем 0.

Предположим, что интерпретатор использует нормальный порядок вычислений.
::
	
	(if (= 0 0)
	    0
	    (p))

	(if (= 0 0)
	    0
            p)
	
	0

Авторы учебника, пишут, что для данного примера нормальный и аппликативный порядки вычислений дают разные результаты. Но почему?

